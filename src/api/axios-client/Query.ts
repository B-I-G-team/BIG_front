//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions  } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type CallbackQueryParameters = {
  code: string;
};

    
export function anonymousUrl(): string {
  let url_ = getBaseUrl() + "/";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let anonymousDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __anonymous,
};
export function getAnonymousDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return anonymousDefaultOptions;
};
export function setAnonymousDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  anonymousDefaultOptions = options;
}

export function anonymousQueryKey(): QueryKey;
export function anonymousQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'anonymous',
    ]);
}
function __anonymous() {
  return Client().anonymous(
    );
}

/**
 * @return Default Response
 */
export function useAnonymousQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAnonymousQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __anonymous,
    queryKey: anonymousQueryKey(),
    ...anonymousDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setAnonymousData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(anonymousQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setAnonymousDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function meUrl(): string {
  let url_ = getBaseUrl() + "/auth/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let meDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __me,
};
export function getMeDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return meDefaultOptions;
};
export function setMeDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  meDefaultOptions = options;
}

export function meQueryKey(): QueryKey;
export function meQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'me',
    ]);
}
function __me() {
  return Client().me(
    );
}

/**
 * @return Default Response
 */
export function useMeQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMeQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __me,
    queryKey: meQueryKey(),
    ...meDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setMeData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(meQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setMeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function kakaoUrl(): string {
  let url_ = getBaseUrl() + "/auth/kakao";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let kakaoDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __kakao,
};
export function getKakaoDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return kakaoDefaultOptions;
};
export function setKakaoDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  kakaoDefaultOptions = options;
}

export function kakaoQueryKey(): QueryKey;
export function kakaoQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'kakao',
    ]);
}
function __kakao() {
  return Client().kakao(
    );
}

/**
 * @return Default Response
 */
export function useKakaoQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useKakaoQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __kakao,
    queryKey: kakaoQueryKey(),
    ...kakaoDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setKakaoData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(kakaoQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setKakaoDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function callbackUrl(code: string): string {
  let url_ = getBaseUrl() + "/auth/kakao/callback?";
  if (code === undefined || code === null)
    throw new Error("The parameter 'code' must be defined and cannot be null.");
  else
    url_ += "code=" + encodeURIComponent("" + code) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let callbackDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __callback,
};
export function getCallbackDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return callbackDefaultOptions;
};
export function setCallbackDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  callbackDefaultOptions = options;
}

export function callbackQueryKey(code: string): QueryKey;
export function callbackQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code,  } = params[0] as CallbackQueryParameters;

    return trimArrayEnd([
        'Client',
        'callback',
        code as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'callback',
        ...params
      ]);
  }
}
function __callback(context: QueryFunctionContext) {
  return Client().callback(
      context.queryKey[2] as string    );
}

export function useCallbackQuery<TSelectData = void, TError = unknown>(dto: CallbackQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Default Response
 * @deprecated
 */
export function useCallbackQuery<TSelectData = void, TError = unknown>(code: string, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCallbackQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let code: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code,  } = params[0] as CallbackQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [code, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __callback,
    queryKey: callbackQueryKey(code),
    ...callbackDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 * @deprecated
 */
export function setCallbackData(queryClient: QueryClient, updater: (data: void | undefined) => void, code: string) {
  queryClient.setQueryData(callbackQueryKey(code),
    updater
  );
}

/**
 * @return Default Response
 * @deprecated
 */
export function setCallbackDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}