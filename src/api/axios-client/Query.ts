//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions  } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);

export type CallbackQueryParameters = {
  code: string;
};

export type BookingsAllQueryParameters = {
  gymID: string;
  firstTime: string;
  lastTime: string;
};

export type CurrentQueryParameters = {
  offset: string | null | undefined;
  limit: string | null | undefined;
};

export type GymGETQueryParameters = {
  offset: string | null | undefined;
  limit: string | null | undefined;
  search: string | null | undefined;
};

export type GymGET2QueryParameters = {
  gymID: string;
};

export type TeamsGETQueryParameters = {
  offset: string | null | undefined;
  limit: string | null | undefined;
  search: string | null | undefined;
};

export type PresignedQueryParameters = {
  extension: string | null | undefined;
};

    
export function anonymousUrl(): string {
  let url_ = getBaseUrl() + "/";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let anonymousDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __anonymous,
};
export function getAnonymousDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return anonymousDefaultOptions;
};
export function setAnonymousDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  anonymousDefaultOptions = options;
}

export function anonymousQueryKey(): QueryKey;
export function anonymousQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'anonymous',
    ]);
}
function __anonymous() {
  return Client().anonymous(
    );
}

/**
 * @return Default Response
 */
export function useAnonymousQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useAnonymousQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: __anonymous,
    queryKey: anonymousQueryKey(),
    ...anonymousDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setAnonymousData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(anonymousQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setAnonymousDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function kakaoUrl(): string {
  let url_ = getBaseUrl() + "/auth/kakao";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let kakaoDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __kakao,
};
export function getKakaoDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return kakaoDefaultOptions;
};
export function setKakaoDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  kakaoDefaultOptions = options;
}

export function kakaoQueryKey(): QueryKey;
export function kakaoQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'kakao',
    ]);
}
function __kakao() {
  return Client().kakao(
    );
}

/**
 * @return Default Response
 */
export function useKakaoQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useKakaoQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: __kakao,
    queryKey: kakaoQueryKey(),
    ...kakaoDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setKakaoData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(kakaoQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setKakaoDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function callbackUrl(code: string): string {
  let url_ = getBaseUrl() + "/auth/kakao/callback?";
  if (code === undefined || code === null)
    throw new Error("The parameter 'code' must be defined and cannot be null.");
  else
    url_ += "code=" + encodeURIComponent("" + code) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let callbackDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __callback,
};
export function getCallbackDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return callbackDefaultOptions;
};
export function setCallbackDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  callbackDefaultOptions = options;
}

export function callbackQueryKey(code: string): QueryKey;
export function callbackQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code,  } = params[0] as CallbackQueryParameters;

    return trimArrayEnd([
        'Client',
        'callback',
        code as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'callback',
        ...params
      ]);
  }
}
function __callback(context: QueryFunctionContext) {
  return Client().callback(
      context.queryKey[2] as string    );
}

export function useCallbackQuery<TSelectData = void, TError = unknown>(dto: CallbackQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @return Default Response
 * @deprecated
 */
export function useCallbackQuery<TSelectData = void, TError = unknown>(code: string, options?: UseQueryOptions<void, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useCallbackQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let code: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code,  } = params[0] as CallbackQueryParameters);
      options = params[1];
    } else {
      [code, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: __callback,
    queryKey: callbackQueryKey(code),
    ...callbackDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 * @deprecated
 */
export function setCallbackData(queryClient: QueryClient, updater: (data: void | undefined) => void, code: string) {
  queryClient.setQueryData(callbackQueryKey(code),
    updater
  );
}

/**
 * @return Default Response
 * @deprecated
 */
export function setCallbackDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function bookingsUrl(): string {
  let url_ = getBaseUrl() + "/bookings";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function bookingsMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'bookings',
    ]);
}

/**
 * @param body (optional) 
 * @return Default Response
 */
export function useBookingsMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous, unknown, Types.Body, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous, unknown, Types.Body, TContext> {
  const key = bookingsMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.Body) => Client().bookings(body), {...options, mutationKey: key});
}
  
    
export function bookingsAllUrl(gymID: string, firstTime: string, lastTime: string): string {
  let url_ = getBaseUrl() + "/bookings?";
  if (gymID === undefined || gymID === null)
    throw new Error("The parameter 'gymID' must be defined and cannot be null.");
  else
    url_ += "gymID=" + encodeURIComponent("" + gymID) + "&";
  if (firstTime === undefined || firstTime === null)
    throw new Error("The parameter 'firstTime' must be defined and cannot be null.");
  else
    url_ += "firstTime=" + encodeURIComponent("" + firstTime) + "&";
  if (lastTime === undefined || lastTime === null)
    throw new Error("The parameter 'lastTime' must be defined and cannot be null.");
  else
    url_ += "lastTime=" + encodeURIComponent("" + lastTime) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let bookingsAllDefaultOptions: UseQueryOptions<Types.Anonymous2[], unknown, Types.Anonymous2[]> = {
  queryFn: __bookingsAll,
};
export function getBookingsAllDefaultOptions(): UseQueryOptions<Types.Anonymous2[], unknown, Types.Anonymous2[]> {
  return bookingsAllDefaultOptions;
};
export function setBookingsAllDefaultOptions(options: UseQueryOptions<Types.Anonymous2[], unknown, Types.Anonymous2[]>) {
  bookingsAllDefaultOptions = options;
}

export function bookingsAllQueryKey(dto: BookingsAllQueryParameters): QueryKey;
export function bookingsAllQueryKey(gymID: string, firstTime: string, lastTime: string): QueryKey;
export function bookingsAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { gymID, firstTime, lastTime,  } = params[0] as BookingsAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'bookingsAll',
        gymID as any,
        firstTime as any,
        lastTime as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'bookingsAll',
        ...params
      ]);
  }
}
function __bookingsAll(context: QueryFunctionContext) {
  return Client().bookingsAll(
      context.queryKey[2] as string,       context.queryKey[3] as string,       context.queryKey[4] as string    );
}

export function useBookingsAllQuery<TSelectData = Types.Anonymous2[], TError = unknown>(dto: BookingsAllQueryParameters, options?: UseQueryOptions<Types.Anonymous2[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @return Default Response
 */
export function useBookingsAllQuery<TSelectData = Types.Anonymous2[], TError = unknown>(gymID: string, firstTime: string, lastTime: string, options?: UseQueryOptions<Types.Anonymous2[], TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useBookingsAllQuery<TSelectData = Types.Anonymous2[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous2[], TError, TSelectData> | undefined = undefined;
  let gymID: any = undefined;
  let firstTime: any = undefined;
  let lastTime: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ gymID, firstTime, lastTime,  } = params[0] as BookingsAllQueryParameters);
      options = params[1];
    } else {
      [gymID, firstTime, lastTime, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous2[], TError, TSelectData>({
    queryFn: __bookingsAll,
    queryKey: bookingsAllQueryKey(gymID, firstTime, lastTime),
    ...bookingsAllDefaultOptions as unknown as UseQueryOptions<Types.Anonymous2[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setBookingsAllData(queryClient: QueryClient, updater: (data: Types.Anonymous2[] | undefined) => Types.Anonymous2[], gymID: string, firstTime: string, lastTime: string) {
  queryClient.setQueryData(bookingsAllQueryKey(gymID, firstTime, lastTime),
    updater
  );
}

/**
 * @return Default Response
 */
export function setBookingsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous2[] | undefined) => Types.Anonymous2[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function currentUrl(offset: string | null | undefined, limit: string | null | undefined): string {
  let url_ = getBaseUrl() + "/bookings/current?";
if (offset !== undefined && offset !== null)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
if (limit !== undefined && limit !== null)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let currentDefaultOptions: UseQueryOptions<Types.Anonymous3, unknown, Types.Anonymous3> = {
  queryFn: __current,
};
export function getCurrentDefaultOptions(): UseQueryOptions<Types.Anonymous3, unknown, Types.Anonymous3> {
  return currentDefaultOptions;
};
export function setCurrentDefaultOptions(options: UseQueryOptions<Types.Anonymous3, unknown, Types.Anonymous3>) {
  currentDefaultOptions = options;
}

export function currentQueryKey(dto: CurrentQueryParameters): QueryKey;
export function currentQueryKey(offset: string | null | undefined, limit: string | null | undefined): QueryKey;
export function currentQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { offset, limit,  } = params[0] as CurrentQueryParameters;

    return trimArrayEnd([
        'Client',
        'current',
        offset as any,
        limit as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'current',
        ...params
      ]);
  }
}
function __current(context: QueryFunctionContext) {
  return Client().current(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined    );
}

export function useCurrentQuery<TSelectData = Types.Anonymous3, TError = unknown>(dto: CurrentQueryParameters, options?: UseQueryOptions<Types.Anonymous3, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @return Default Response
 */
export function useCurrentQuery<TSelectData = Types.Anonymous3, TError = unknown>(offset: string | null | undefined, limit: string | null | undefined, options?: UseQueryOptions<Types.Anonymous3, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useCurrentQuery<TSelectData = Types.Anonymous3, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous3, TError, TSelectData> | undefined = undefined;
  let offset: any = undefined;
  let limit: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ offset, limit,  } = params[0] as CurrentQueryParameters);
      options = params[1];
    } else {
      [offset, limit, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous3, TError, TSelectData>({
    queryFn: __current,
    queryKey: currentQueryKey(offset, limit),
    ...currentDefaultOptions as unknown as UseQueryOptions<Types.Anonymous3, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @return Default Response
 */
export function setCurrentData(queryClient: QueryClient, updater: (data: Types.Anonymous3 | undefined) => Types.Anonymous3, offset: string | null | undefined, limit: string | null | undefined) {
  queryClient.setQueryData(currentQueryKey(offset, limit),
    updater
  );
}

/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @return Default Response
 */
export function setCurrentDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous3 | undefined) => Types.Anonymous3) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gymPOSTUrl(): string {
  let url_ = getBaseUrl() + "/gym";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gymPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'gymPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Default Response
 */
export function useGymPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous4, unknown, Types.Body2, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous4, unknown, Types.Body2, TContext> {
  const key = gymPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.Body2) => Client().gymPOST(body), {...options, mutationKey: key});
}
  
    
export function gymGETUrl(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined): string {
  let url_ = getBaseUrl() + "/gym?";
if (offset !== undefined && offset !== null)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
if (limit !== undefined && limit !== null)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (search !== undefined && search !== null)
    url_ += "search=" + encodeURIComponent("" + search) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gymGETDefaultOptions: UseQueryOptions<Types.Anonymous5, unknown, Types.Anonymous5> = {
  queryFn: __gymGET,
};
export function getGymGETDefaultOptions(): UseQueryOptions<Types.Anonymous5, unknown, Types.Anonymous5> {
  return gymGETDefaultOptions;
};
export function setGymGETDefaultOptions(options: UseQueryOptions<Types.Anonymous5, unknown, Types.Anonymous5>) {
  gymGETDefaultOptions = options;
}

export function gymGETQueryKey(dto: GymGETQueryParameters): QueryKey;
export function gymGETQueryKey(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined): QueryKey;
export function gymGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { offset, limit, search,  } = params[0] as GymGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'gymGET',
        offset as any,
        limit as any,
        search as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gymGET',
        ...params
      ]);
  }
}
function __gymGET(context: QueryFunctionContext) {
  return Client().gymGET(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined    );
}

export function useGymGETQuery<TSelectData = Types.Anonymous5, TError = unknown>(dto: GymGETQueryParameters, options?: UseQueryOptions<Types.Anonymous5, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function useGymGETQuery<TSelectData = Types.Anonymous5, TError = unknown>(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined, options?: UseQueryOptions<Types.Anonymous5, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useGymGETQuery<TSelectData = Types.Anonymous5, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous5, TError, TSelectData> | undefined = undefined;
  let offset: any = undefined;
  let limit: any = undefined;
  let search: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ offset, limit, search,  } = params[0] as GymGETQueryParameters);
      options = params[1];
    } else {
      [offset, limit, search, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous5, TError, TSelectData>({
    queryFn: __gymGET,
    queryKey: gymGETQueryKey(offset, limit, search),
    ...gymGETDefaultOptions as unknown as UseQueryOptions<Types.Anonymous5, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function setGymGETData(queryClient: QueryClient, updater: (data: Types.Anonymous5 | undefined) => Types.Anonymous5, offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined) {
  queryClient.setQueryData(gymGETQueryKey(offset, limit, search),
    updater
  );
}

/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function setGymGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous5 | undefined) => Types.Anonymous5) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gymGET2Url(gymID: string): string {
  let url_ = getBaseUrl() + "/gym/{gymID}";

if (gymID === undefined || gymID === null)
  throw new Error("The parameter 'gymID' must be defined.");
url_ = url_.replace("{gymID}", encodeURIComponent("" + gymID));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gymGET2DefaultOptions: UseQueryOptions<Types.Anonymous6, unknown, Types.Anonymous6> = {
  queryFn: __gymGET2,
};
export function getGymGET2DefaultOptions(): UseQueryOptions<Types.Anonymous6, unknown, Types.Anonymous6> {
  return gymGET2DefaultOptions;
};
export function setGymGET2DefaultOptions(options: UseQueryOptions<Types.Anonymous6, unknown, Types.Anonymous6>) {
  gymGET2DefaultOptions = options;
}

export function gymGET2QueryKey(gymID: string): QueryKey;
export function gymGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { gymID,  } = params[0] as GymGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'gymGET2',
        gymID as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gymGET2',
        ...params
      ]);
  }
}
function __gymGET2(context: QueryFunctionContext) {
  return Client().gymGET2(
      context.queryKey[2] as string    );
}

export function useGymGET2Query<TSelectData = Types.Anonymous6, TError = unknown>(dto: GymGET2QueryParameters, options?: UseQueryOptions<Types.Anonymous6, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @return Default Response
 */
export function useGymGET2Query<TSelectData = Types.Anonymous6, TError = unknown>(gymID: string, options?: UseQueryOptions<Types.Anonymous6, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useGymGET2Query<TSelectData = Types.Anonymous6, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous6, TError, TSelectData> | undefined = undefined;
  let gymID: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ gymID,  } = params[0] as GymGET2QueryParameters);
      options = params[1];
    } else {
      [gymID, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous6, TError, TSelectData>({
    queryFn: __gymGET2,
    queryKey: gymGET2QueryKey(gymID),
    ...gymGET2DefaultOptions as unknown as UseQueryOptions<Types.Anonymous6, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setGymGET2Data(queryClient: QueryClient, updater: (data: Types.Anonymous6 | undefined) => Types.Anonymous6, gymID: string) {
  queryClient.setQueryData(gymGET2QueryKey(gymID),
    updater
  );
}

/**
 * @return Default Response
 */
export function setGymGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous6 | undefined) => Types.Anonymous6) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function teamsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/teams";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Default Response
 */
export function useTeamsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous8, unknown, Types.Body3, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous8, unknown, Types.Body3, TContext> {
  const key = teamsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.Body3) => Client().teamsPOST(body), {...options, mutationKey: key});
}
  
    
export function teamsGETUrl(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined): string {
  let url_ = getBaseUrl() + "/teams?";
if (offset !== undefined && offset !== null)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
if (limit !== undefined && limit !== null)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (search !== undefined && search !== null)
    url_ += "search=" + encodeURIComponent("" + search) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let teamsGETDefaultOptions: UseQueryOptions<Types.Anonymous9, unknown, Types.Anonymous9> = {
  queryFn: __teamsGET,
};
export function getTeamsGETDefaultOptions(): UseQueryOptions<Types.Anonymous9, unknown, Types.Anonymous9> {
  return teamsGETDefaultOptions;
};
export function setTeamsGETDefaultOptions(options: UseQueryOptions<Types.Anonymous9, unknown, Types.Anonymous9>) {
  teamsGETDefaultOptions = options;
}

export function teamsGETQueryKey(dto: TeamsGETQueryParameters): QueryKey;
export function teamsGETQueryKey(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined): QueryKey;
export function teamsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { offset, limit, search,  } = params[0] as TeamsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'teamsGET',
        offset as any,
        limit as any,
        search as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'teamsGET',
        ...params
      ]);
  }
}
function __teamsGET(context: QueryFunctionContext) {
  return Client().teamsGET(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as string | null | undefined,       context.queryKey[4] as string | null | undefined    );
}

export function useTeamsGETQuery<TSelectData = Types.Anonymous9, TError = unknown>(dto: TeamsGETQueryParameters, options?: UseQueryOptions<Types.Anonymous9, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function useTeamsGETQuery<TSelectData = Types.Anonymous9, TError = unknown>(offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined, options?: UseQueryOptions<Types.Anonymous9, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useTeamsGETQuery<TSelectData = Types.Anonymous9, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous9, TError, TSelectData> | undefined = undefined;
  let offset: any = undefined;
  let limit: any = undefined;
  let search: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ offset, limit, search,  } = params[0] as TeamsGETQueryParameters);
      options = params[1];
    } else {
      [offset, limit, search, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous9, TError, TSelectData>({
    queryFn: __teamsGET,
    queryKey: teamsGETQueryKey(offset, limit, search),
    ...teamsGETDefaultOptions as unknown as UseQueryOptions<Types.Anonymous9, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function setTeamsGETData(queryClient: QueryClient, updater: (data: Types.Anonymous9 | undefined) => Types.Anonymous9, offset: string | null | undefined, limit: string | null | undefined, search: string | null | undefined) {
  queryClient.setQueryData(teamsGETQueryKey(offset, limit, search),
    updater
  );
}

/**
 * @param offset (optional) number
 * @param limit (optional) number
 * @param search (optional) 검색어
 * @return Default Response
 */
export function setTeamsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous9 | undefined) => Types.Anonymous9) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function presignedUrl(extension: string | null | undefined): string {
  let url_ = getBaseUrl() + "/upload/presigned?";
if (extension !== undefined && extension !== null)
    url_ += "extension=" + encodeURIComponent("" + extension) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let presignedDefaultOptions: UseQueryOptions<Types.Anonymous10, unknown, Types.Anonymous10> = {
  queryFn: __presigned,
};
export function getPresignedDefaultOptions(): UseQueryOptions<Types.Anonymous10, unknown, Types.Anonymous10> {
  return presignedDefaultOptions;
};
export function setPresignedDefaultOptions(options: UseQueryOptions<Types.Anonymous10, unknown, Types.Anonymous10>) {
  presignedDefaultOptions = options;
}

export function presignedQueryKey(extension: string | null | undefined): QueryKey;
export function presignedQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { extension,  } = params[0] as PresignedQueryParameters;

    return trimArrayEnd([
        'Client',
        'presigned',
        extension as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'presigned',
        ...params
      ]);
  }
}
function __presigned(context: QueryFunctionContext) {
  return Client().presigned(
      context.queryKey[2] as string | null | undefined    );
}

export function usePresignedQuery<TSelectData = Types.Anonymous10, TError = unknown>(dto: PresignedQueryParameters, options?: UseQueryOptions<Types.Anonymous10, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
/**
 * @param extension (optional) 파일의 확장자 (ex. png, jpeg, ...)
 * @return Default Response
 */
export function usePresignedQuery<TSelectData = Types.Anonymous10, TError = unknown>(extension: string | null | undefined, options?: UseQueryOptions<Types.Anonymous10, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function usePresignedQuery<TSelectData = Types.Anonymous10, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous10, TError, TSelectData> | undefined = undefined;
  let extension: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ extension,  } = params[0] as PresignedQueryParameters);
      options = params[1];
    } else {
      [extension, options] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous10, TError, TSelectData>({
    queryFn: __presigned,
    queryKey: presignedQueryKey(extension),
    ...presignedDefaultOptions as unknown as UseQueryOptions<Types.Anonymous10, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param extension (optional) 파일의 확장자 (ex. png, jpeg, ...)
 * @return Default Response
 */
export function setPresignedData(queryClient: QueryClient, updater: (data: Types.Anonymous10 | undefined) => Types.Anonymous10, extension: string | null | undefined) {
  queryClient.setQueryData(presignedQueryKey(extension),
    updater
  );
}

/**
 * @param extension (optional) 파일의 확장자 (ex. png, jpeg, ...)
 * @return Default Response
 */
export function setPresignedDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous10 | undefined) => Types.Anonymous10) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function meGETUrl(): string {
  let url_ = getBaseUrl() + "/users/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let meGETDefaultOptions: UseQueryOptions<Types.Anonymous11, unknown, Types.Anonymous11> = {
  queryFn: __meGET,
};
export function getMeGETDefaultOptions(): UseQueryOptions<Types.Anonymous11, unknown, Types.Anonymous11> {
  return meGETDefaultOptions;
};
export function setMeGETDefaultOptions(options: UseQueryOptions<Types.Anonymous11, unknown, Types.Anonymous11>) {
  meGETDefaultOptions = options;
}

export function meGETQueryKey(): QueryKey;
export function meGETQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'meGET',
    ]);
}
function __meGET() {
  return Client().meGET(
    );
}

/**
 * @return Default Response
 */
export function useMeGETQuery<TSelectData = Types.Anonymous11, TError = unknown>(options?: UseQueryOptions<Types.Anonymous11, TError, TSelectData>): UseQueryResult<TSelectData, TError>;
export function useMeGETQuery<TSelectData = Types.Anonymous11, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Anonymous11, TError, TSelectData> | undefined = undefined;
  

  options = params[0] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Anonymous11, TError, TSelectData>({
    queryFn: __meGET,
    queryKey: meGETQueryKey(),
    ...meGETDefaultOptions as unknown as UseQueryOptions<Types.Anonymous11, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Default Response
 */
export function setMeGETData(queryClient: QueryClient, updater: (data: Types.Anonymous11 | undefined) => Types.Anonymous11, ) {
  queryClient.setQueryData(meGETQueryKey(),
    updater
  );
}

/**
 * @return Default Response
 */
export function setMeGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Anonymous11 | undefined) => Types.Anonymous11) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mePUTUrl(): string {
  let url_ = getBaseUrl() + "/users/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mePUTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'mePUT',
    ]);
}

/**
 * @param body (optional) 
 * @return Default Response
 */
export function useMePUTMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous12, unknown, Types.Body4, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous12, unknown, Types.Body4, TContext> {
  const key = mePUTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.Body4) => Client().mePUT(body), {...options, mutationKey: key});
}